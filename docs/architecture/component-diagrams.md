# ELYSIUM Component Interaction Diagrams

**Version:** v1.0  
**Last Updated:** September 9, 2025  
**Generated By:** BMad Architecture Agent  

---

## Overview

This document provides visual representations of the ELYSIUM platform's component interactions, data flows, and system architecture. These diagrams help developers understand the relationships between different parts of the system.

---

## System Architecture Diagram

```mermaid
graph TB
    subgraph "Client Layer"
        Browser[Web Browser]
        Mobile[Mobile Browser]
    end
    
    subgraph "CDN & Edge"
        CDN[Vercel Edge Network]
        Images[Image CDN - Sanity]
    end
    
    subgraph "Application Layer - Next.js 15"
        App[Next.js App Router]
        API[API Routes]
        SSG[Static Site Generation]
        SSR[Server Side Rendering]
    end
    
    subgraph "State Management"
        Zustand[Zustand Store]
        SWR[SWR Cache]
        URL[URL State]
    end
    
    subgraph "External Services"
        Sanity[Sanity CMS]
        Stripe[Stripe Payments]
        Resend[Resend Email]
        Analytics[Plausible Analytics]
    end
    
    Browser --> CDN
    Mobile --> CDN
    CDN --> App
    App --> API
    App --> SSG
    App --> SSR
    App --> Zustand
    App --> SWR
    App --> URL
    API --> Sanity
    API --> Stripe
    API --> Resend
    Browser --> Analytics
    Mobile --> Analytics
    Images --> CDN
    Sanity --> Images
```

---

## User Journey Flow Diagrams

### 1. Product Discovery Journey
```mermaid
sequenceDiagram
    participant U as User
    participant B as Browser
    participant CDN as Edge CDN
    participant App as Next.js App
    participant SWR as SWR Cache
    participant Sanity as Sanity CMS
    
    U->>B: Visit ELYSIUM homepage
    B->>CDN: Request static assets
    CDN->>B: Serve cached assets
    B->>App: Request page data
    App->>SWR: Check cache for products
    alt Cache Miss
        SWR->>Sanity: Query products
        Sanity->>SWR: Return product data
        SWR->>App: Cache and return data
    else Cache Hit
        SWR->>App: Return cached data
    end
    App->>B: Render product grid
    B->>U: Display luxury product collection
    
    U->>B: Apply filters (metal: gold)
    B->>App: Update filter state
    App->>SWR: Request filtered products
    SWR->>Sanity: Query with filters
    Sanity->>SWR: Return filtered results
    SWR->>App: Update cache
    App->>B: Re-render filtered grid
    B->>U: Show filtered products
```

### 2. Product Configuration Journey
```mermaid
sequenceDiagram
    participant U as User
    participant B as Browser
    participant App as Next.js App
    participant Z as Zustand Store
    participant URL as URL State
    participant Sanity as Sanity CMS
    
    U->>B: Click on product
    B->>App: Navigate to PDP
    App->>Sanity: Load product details
    Sanity->>App: Return product data
    App->>Z: Initialize product state
    Z->>URL: Update URL with defaults
    App->>B: Render product configurator
    
    U->>B: Change metal to Rose Gold
    B->>App: Handle configuration change
    App->>Z: Update product state
    Z->>URL: Update shareable URL
    Z->>App: Trigger price calculation
    App->>B: Update price display
    B->>U: Show new configuration & price
    
    U->>B: Add to cart
    B->>App: Add configured product
    App->>Z: Update cart state
    Z->>App: Calculate cart totals
    App->>B: Show cart confirmation
    B->>U: Display success feedback
```

### 3. Checkout & Payment Journey
```mermaid
sequenceDiagram
    participant U as User
    participant B as Browser
    participant App as Next.js App
    participant API as API Routes
    participant Stripe as Stripe
    participant Resend as Resend Email
    
    U->>B: Click checkout
    B->>App: Navigate to checkout
    App->>B: Show cart summary
    
    U->>B: Fill shipping details
    B->>App: Validate form data
    App->>API: Create checkout session
    API->>Stripe: Create payment intent
    Stripe->>API: Return session details
    API->>App: Return checkout URL
    App->>B: Redirect to Stripe
    
    U->>Stripe: Complete payment
    Stripe->>B: Redirect to success page
    B->>App: Load success page
    App->>API: Confirm order
    API->>Resend: Send confirmation email
    Resend->>U: Delivery confirmation
    App->>B: Show order confirmation
```

---

## Component Architecture Diagrams

### 1. Page Component Hierarchy
```mermaid
graph TD
    Layout[Root Layout] --> Header[Header Component]
    Layout --> Main[Main Content]
    Layout --> Footer[Footer Component]
    
    Header --> Navigation[Navigation Menu]
    Header --> SearchBar[Search Bar]
    Header --> CartIcon[Mini Cart Icon]
    Header --> WishlistIcon[Wishlist Icon]
    
    Main --> HomePage[Home Page]
    Main --> ProductPage[Product Detail Page]
    Main --> CollectionPage[Collection Page]
    Main --> CheckoutPage[Checkout Page]
    
    HomePage --> HeroSection[Hero Section]
    HomePage --> CollectionGrid[Collection Grid]
    HomePage --> TrustStrip[Trust Strip]
    HomePage --> Testimonials[Testimonials]
    
    ProductPage --> ProductGallery[Product Gallery]
    ProductPage --> ConfigSection[Configuration Section]
    ProductPage --> StickySection[Sticky Summary]
    ProductPage --> ReviewsSection[Reviews Section]
    
    ConfigSection --> MetalSelector[Metal Selector]
    ConfigSection --> StoneSelector[Stone Selector]
    ConfigSection --> SizeGuide[Size Guide]
    ConfigSection --> PriceDisplay[Price Display]
```

### 2. State Management Flow
```mermaid
graph LR
    subgraph "UI Components"
        ProductCard[Product Card]
        CartDrawer[Cart Drawer]
        ConfigForm[Config Form]
        CheckoutForm[Checkout Form]
    end
    
    subgraph "Zustand Stores"
        CartStore[Cart Store]
        WishlistStore[Wishlist Store]
        UIStore[UI Store]
    end
    
    subgraph "Data Layer"
        SWRCache[SWR Cache]
        LocalStorage[Local Storage]
        URLState[URL State]
    end
    
    ProductCard --> CartStore
    ProductCard --> WishlistStore
    CartDrawer --> CartStore
    ConfigForm --> URLState
    CheckoutForm --> CartStore
    
    CartStore --> LocalStorage
    WishlistStore --> LocalStorage
    UIStore --> LocalStorage
    
    CartStore --> SWRCache
    WishlistStore --> SWRCache
    
    URLState --> ConfigForm
```

---

## API Integration Patterns

### 1. Product API Integration
```mermaid
graph TD
    subgraph "Frontend Components"
        ProductGrid[Product Grid]
        FilterBar[Filter Bar]
        SearchBox[Search Box]
    end
    
    subgraph "Data Fetching Layer"
        useSWR[useSWR Hook]
        FilterHook[useFilters Hook]
    end
    
    subgraph "API Layer"
        ProductsAPI[/api/products]
        SanityQueries[Sanity Queries]
    end
    
    ProductGrid --> useSWR
    FilterBar --> FilterHook
    SearchBox --> FilterHook
    
    useSWR --> ProductsAPI
    FilterHook --> ProductsAPI
    
    ProductsAPI --> SanityQueries
    SanityQueries --> Sanity[(Sanity CMS)]
```

### 2. Checkout API Integration
```mermaid
graph TD
    subgraph "Checkout Components"
        CartSummary[Cart Summary]
        CheckoutForm[Checkout Form]
        PaymentButton[Payment Button]
    end
    
    subgraph "API Integration"
        CheckoutAPI[/api/checkout]
        StripeAPI[Stripe API]
    end
    
    subgraph "External Services"
        StripeCheckout[Stripe Checkout]
        PaymentSuccess[Success Page]
    end
    
    CartSummary --> CheckoutAPI
    CheckoutForm --> CheckoutAPI
    PaymentButton --> CheckoutAPI
    
    CheckoutAPI --> StripeAPI
    StripeAPI --> StripeCheckout
    StripeCheckout --> PaymentSuccess
```

---

## Data Flow Diagrams

### 1. Product Data Flow
```mermaid
flowchart TD
    A[Sanity CMS] -->|Content API| B[Next.js API Route]
    B -->|Processed Data| C[SWR Cache]
    C -->|Cached Response| D[Product Components]
    D -->|User Interaction| E[Zustand State]
    E -->|State Change| F[URL State Update]
    F -->|Share/Bookmark| G[Shareable URL]
    
    C -->|Background Revalidation| B
    E -->|Add to Cart| H[Cart State]
    E -->|Add to Wishlist| I[Wishlist State]
    H -->|Persist| J[Local Storage]
    I -->|Persist| J
```

### 2. Image Optimization Flow
```mermaid
flowchart LR
    A[Sanity Asset] -->|CDN URL| B[Next.js Image]
    B -->|Optimization| C[WebP/AVIF]
    C -->|Responsive| D[Multiple Sizes]
    D -->|Lazy Load| E[Browser Display]
    
    B -->|Fallback| F[Original Format]
    F -->|Progressive| E
    
    C -->|Cache| G[CDN Edge Cache]
    G -->|Global| H[Fast Delivery]
```

---

## Security Architecture

### 1. Data Protection Flow
```mermaid
graph TD
    subgraph "Client Side"
        Browser[Browser]
        FormData[Form Data]
    end
    
    subgraph "Transport Layer"
        HTTPS[HTTPS/TLS 1.3]
        Headers[Security Headers]
    end
    
    subgraph "Application Layer"
        NextJS[Next.js App]
        Validation[Input Validation]
        Sanitization[Data Sanitization]
    end
    
    subgraph "External Services"
        StripeSecure[Stripe PCI DSS]
        SanitySecure[Sanity HTTPS]
        EmailSecure[Resend Secure API]
    end
    
    Browser --> HTTPS
    FormData --> Validation
    HTTPS --> NextJS
    NextJS --> Validation
    Validation --> Sanitization
    Sanitization --> StripeSecure
    Sanitization --> SanitySecure
    Sanitization --> EmailSecure
    
    Headers --> Browser
```

### 2. Authentication Flow (Future Implementation)
```mermaid
sequenceDiagram
    participant U as User
    participant C as Client App
    participant API as API Server
    participant JWT as JWT Service
    participant DB as Database
    
    U->>C: Login Request
    C->>API: Send Credentials
    API->>DB: Validate User
    DB->>API: User Valid
    API->>JWT: Generate Token
    JWT->>API: JWT Token
    API->>C: Return Token
    C->>C: Store Token
    
    Note over C: Subsequent Requests
    C->>API: Request + JWT Header
    API->>JWT: Validate Token
    JWT->>API: Token Valid
    API->>DB: Process Request
    DB->>API: Return Data
    API->>C: Protected Response
```

---

## Performance Architecture

### 1. Caching Strategy
```mermaid
graph TD
    subgraph "Browser Cache"
        BrowserCache[Browser Cache]
        ServiceWorker[Service Worker]
    end
    
    subgraph "CDN Layer"
        EdgeCache[Edge Cache]
        ImageCache[Image Cache]
    end
    
    subgraph "Application Cache"
        SWRCache[SWR Cache]
        NextJSCache[Next.js Cache]
        StaticCache[Static Generation]
    end
    
    subgraph "Data Cache"
        APICache[API Response Cache]
        SanityCache[Sanity CDN Cache]
    end
    
    User[User Request] --> BrowserCache
    BrowserCache --> EdgeCache
    EdgeCache --> SWRCache
    SWRCache --> APICache
    APICache --> SanityCache
    
    StaticCache --> EdgeCache
    ImageCache --> EdgeCache
    ServiceWorker --> BrowserCache
```

### 2. Loading Strategy
```mermaid
flowchart TD
    A[Page Request] --> B{Static or Dynamic?}
    B -->|Static| C[Static Generation]
    B -->|Dynamic| D[Server Rendering]
    
    C --> E[HTML Cache]
    D --> F[Runtime Generation]
    
    E --> G[CDN Delivery]
    F --> G
    
    G --> H[Browser Receives HTML]
    H --> I[Hydration]
    I --> J[Client Interactivity]
    
    J --> K[Lazy Load Images]
    J --> L[Code Splitting]
    K --> M[Progressive Enhancement]
    L --> M
```

---

## Mobile-First Architecture

### 1. Responsive Component Strategy
```mermaid
graph TD
    subgraph "Design Tokens"
        Breakpoints[Responsive Breakpoints]
        Spacing[Spacing System]
        Typography[Typography Scale]
    end
    
    subgraph "Component Variants"
        MobileNav[Mobile Navigation]
        DesktopNav[Desktop Navigation]
        TouchOptimized[Touch Components]
        HoverStates[Hover Interactions]
    end
    
    subgraph "Performance Optimizations"
        ImageSizes[Responsive Images]
        TouchTargets[Touch Target Sizing]
        GestureHandling[Gesture Recognition]
    end
    
    Breakpoints --> MobileNav
    Breakpoints --> DesktopNav
    Spacing --> TouchTargets
    Typography --> TouchOptimized
    
    MobileNav --> GestureHandling
    TouchOptimized --> TouchTargets
    ImageSizes --> Performance[Performance Optimization]
```

---

## Monitoring & Observability

### 1. Monitoring Data Flow
```mermaid
graph TD
    subgraph "Application Events"
        PageViews[Page Views]
        UserActions[User Actions]
        Errors[Error Events]
        Performance[Performance Metrics]
    end
    
    subgraph "Collection Layer"
        Analytics[Plausible Analytics]
        ErrorTracking[Error Tracking]
        APM[Performance Monitoring]
    end
    
    subgraph "Storage & Analysis"
        LogStorage[Log Storage]
        MetricsDB[Metrics Database]
        Dashboards[Monitoring Dashboards]
    end
    
    PageViews --> Analytics
    UserActions --> Analytics
    Errors --> ErrorTracking
    Performance --> APM
    
    Analytics --> MetricsDB
    ErrorTracking --> LogStorage
    APM --> MetricsDB
    
    LogStorage --> Dashboards
    MetricsDB --> Dashboards
```

---

## Future Architecture Considerations

### 1. Microservices Evolution
```mermaid
graph TD
    subgraph "Current Monolithic API"
        CurrentAPI[Next.js API Routes]
    end
    
    subgraph "Future Microservices"
        ProductService[Product Service]
        OrderService[Order Service]
        UserService[User Service]
        NotificationService[Notification Service]
        InventoryService[Inventory Service]
    end
    
    subgraph "API Gateway"
        Gateway[API Gateway]
        LoadBalancer[Load Balancer]
        RateLimit[Rate Limiting]
    end
    
    CurrentAPI -.->|Migration| ProductService
    CurrentAPI -.->|Migration| OrderService
    CurrentAPI -.->|Migration| UserService
    
    ProductService --> Gateway
    OrderService --> Gateway
    UserService --> Gateway
    NotificationService --> Gateway
    InventoryService --> Gateway
    
    Gateway --> LoadBalancer
    Gateway --> RateLimit
```

### 2. International Expansion Architecture
```mermaid
graph TD
    subgraph "Multi-Region Deployment"
        USRegion[US East Region]
        EURegion[EU West Region]
        APRegion[Asia Pacific Region]
    end
    
    subgraph "Global Services"
        CDN[Global CDN]
        DNS[GeoDNS]
        LoadBalancer[Global Load Balancer]
    end
    
    subgraph "Localization Services"
        i18n[Internationalization]
        Currency[Currency Service]
        Shipping[Regional Shipping]
        Compliance[Regional Compliance]
    end
    
    User[Global Users] --> DNS
    DNS --> LoadBalancer
    LoadBalancer --> USRegion
    LoadBalancer --> EURegion
    LoadBalancer --> APRegion
    
    CDN --> USRegion
    CDN --> EURegion
    CDN --> APRegion
    
    i18n --> Currency
    i18n --> Shipping
    i18n --> Compliance
```

---

## Conclusion

These diagrams provide a comprehensive view of the ELYSIUM platform's architecture, from high-level system interactions to detailed component relationships. They serve as living documentation that should be updated as the system evolves.

**Key Architectural Principles Visualized:**
- **Performance-First Design:** Caching at every layer
- **Security by Design:** Protection throughout the data flow
- **Mobile-First Approach:** Responsive and touch-optimized
- **Scalability Planning:** Ready for microservices evolution
- **Global Reach:** International expansion considerations

*These diagrams should be reviewed and updated with each major architectural change or new feature implementation.*